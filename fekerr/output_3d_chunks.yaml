- chunk_id: '001'
  description: Chunk 1
  enabled: true
  content: 'import numpy as np

    '
  metadata:
    performance: {}
    history: Chunk generated from lines 1 to 1.
    error_bars: null
- chunk_id: '002'
  description: Chunk 2
  enabled: true
  content: 'import matplotlib.pyplot as plt

    '
  metadata:
    performance: {}
    history: Chunk generated from lines 2 to 2.
    error_bars: null
- chunk_id: '003'
  description: Chunk 3
  enabled: true
  content: 'from matplotlib.animation import FuncAnimation, PillowWriter

    '
  metadata:
    performance: {}
    history: Chunk generated from lines 3 to 3.
    error_bars: null
- chunk_id: '004'
  description: Chunk 4
  enabled: true
  content: 'from mpl_toolkits.mplot3d import Axes3D

    '
  metadata:
    performance: {}
    history: Chunk generated from lines 4 to 4.
    error_bars: null
- chunk_id: '005'
  description: Chunk 5
  enabled: true
  content: 'import matplotlib.colors as mcolors

    '
  metadata:
    performance: {}
    history: Chunk generated from lines 5 to 5.
    error_bars: null
- chunk_id: '006'
  description: Chunk 6
  enabled: true
  content: 'from matplotlib.animation import FFMpegWriter

    '
  metadata:
    performance: {}
    history: Chunk generated from lines 6 to 6.
    error_bars: null
- chunk_id: '007'
  description: Chunk 7
  enabled: true
  content: 'import os


    '
  metadata:
    performance: {}
    history: Chunk generated from lines 7 to 8.
    error_bars: null
- chunk_id: 008
  description: Chunk 8
  enabled: true
  content: 'OS_PATH = os.path.dirname(os.path.realpath(''__file__''))


    '
  metadata:
    performance: {}
    history: Chunk generated from lines 9 to 10.
    error_bars: null
- chunk_id: 009
  description: Chunk 9
  enabled: true
  content: "class Config:\n    SETTINGS = {\n        'frames': 3000,\n        'camera_distance':\
    \ 100,\n        'min_camera_distance': 3,\n        'max_camera_distance': 100000,\n\
    \        'zoom_speed': 0.0075,\n        'base_speed': 0.2,\n        'asteroid_counts':\
    \ {\n            'belt': 2000,\n            'hildas': 300,\n            'trojans':\
    \ 300,\n            'kuiper': 4000,\n            'inner_oort': 40000,\n      \
    \      'outer_oort': 60000,\n        },\n        'planets': {\n            'Mercury':\
    \ {\n                'color': 'gray',\n                'size': 20,\n         \
    \       'orbital_period': 0.24,\n                'orbital_radius': 1,\n      \
    \          'inclination': 7.0,\n                'moons': {}  # Mercury has no\
    \ moons\n            },\n            'Venus': {\n                'color': 'orange',\n\
    \                'size': 30,\n                'orbital_period': 0.62,\n      \
    \          'orbital_radius': 1.8,\n                'inclination': 3.4,\n     \
    \           'moons': {}  # Venus has no moons\n            },\n            'Earth':\
    \ {\n                'color': 'blue',\n                'size': 30,\n         \
    \       'orbital_period': 1.0,\n                'orbital_radius': 2.5,\n     \
    \           'inclination': 0.0,\n                'moons': {\n                \
    \    'Moon': {\n                        'color': 'gray',\n                   \
    \     'size': 8,  # Relative to Earth\n                        'orbital_period':\
    \ 27.32,  # In Earth days\n                        'orbital_radius': 30.3,   #\
    \ In Earth radii\n                        'inclination': 5.145      # Degrees\
    \ relative to Earth's equator\n                    }\n                }\n    \
    \        },\n            'Mars': {\n                'color': 'red',\n        \
    \        'size': 25,\n                'orbital_period': 1.88,\n              \
    \  'orbital_radius': 3.8,\n                'inclination': 1.9,\n             \
    \   'moons': {\n                    'Phobos': {\n                        'color':\
    \ 'gray',\n                        'size': 2,\n                        'orbital_period':\
    \ 0.319,\n                        'orbital_radius': 4.76,\n                  \
    \      'inclination': 1.093\n                    },\n                    'Deimos':\
    \ {\n                        'color': 'gray',\n                        'size':\
    \ 1,\n                        'orbital_period': 1.263,\n                     \
    \   'orbital_radius': 12.92,\n                        'inclination': 0.93\n  \
    \                  }\n                }\n            },\n            'Jupiter':\
    \ {\n                'color': 'orange',\n                'size': 60,\n       \
    \         'orbital_period': 11.86,\n                'orbital_radius': 13,\n  \
    \              'inclination': 1.3,\n                'moons': {\n             \
    \       'Io': {\n                        'color': 'yellow',\n                \
    \        'size': 10,\n                        'orbital_period': 1.769,\n     \
    \                   'orbital_radius': 5.9,\n                        'inclination':\
    \ 0.04\n                    },\n                    'Europa': {\n            \
    \            'color': 'white',\n                        'size': 8,\n         \
    \               'orbital_period': 3.551,\n                        'orbital_radius':\
    \ 9.4,\n                        'inclination': 0.47\n                    },\n\
    \                    'Ganymede': {\n                        'color': 'gray',\n\
    \                        'size': 12,\n                        'orbital_period':\
    \ 7.155,\n                        'orbital_radius': 15.0,\n                  \
    \      'inclination': 0.21\n                    },\n                    'Callisto':\
    \ {\n                        'color': 'darkgray',\n                        'size':\
    \ 11,\n                        'orbital_period': 16.689,\n                   \
    \     'orbital_radius': 26.4,\n                        'inclination': 0.51\n \
    \                   }\n                }\n            },\n            'Saturn':\
    \ {\n                'color': 'gold',\n                'size': 55,\n         \
    \       'orbital_period': 29.46,\n                'orbital_radius': 24,\n    \
    \            'inclination': 2.5,\n                'moons': {\n               \
    \     'Mimas': {\n                        'color': 'gray',\n                 \
    \       'size': 3,\n                        'orbital_period': 0.942,\n       \
    \                 'orbital_radius': 3.08,\n                        'inclination':\
    \ 1.53\n                    },\n                    'Enceladus': {\n         \
    \               'color': 'white',\n                        'size': 4,\n      \
    \                  'orbital_period': 1.370,\n                        'orbital_radius':\
    \ 3.95,\n                        'inclination': 0.00\n                    },\n\
    \                    'Tethys': {\n                        'color': 'gray',\n \
    \                       'size': 5,\n                        'orbital_period':\
    \ 1.888,\n                        'orbital_radius': 4.89,\n                  \
    \      'inclination': 1.09\n                    },\n                    'Dione':\
    \ {\n                        'color': 'lightgray',\n                        'size':\
    \ 5,\n                        'orbital_period': 2.737,\n                     \
    \   'orbital_radius': 6.26,\n                        'inclination': 0.02\n   \
    \                 },\n                    'Rhea': {\n                        'color':\
    \ 'lightgray',\n                        'size': 6,\n                        'orbital_period':\
    \ 4.518,\n                        'orbital_radius': 8.74,\n                  \
    \      'inclination': 0.35\n                    },\n                    'Titan':\
    \ {\n                        'color': 'orange',\n                        'size':\
    \ 12,\n                        'orbital_period': 15.945,\n                   \
    \     'orbital_radius': 20.27,\n                        'inclination': 0.33\n\
    \                    },\n                    'Iapetus': {\n                  \
    \      'color': 'gray',\n                        'size': 6,\n                \
    \        'orbital_period': 79.321,\n                        'orbital_radius':\
    \ 59.02,\n                        'inclination': 15.47\n                    }\n\
    \                }\n            },\n            'Uranus': {\n                'color':\
    \ 'lightblue',\n                'size': 45,\n                'orbital_period':\
    \ 84.01,\n                'orbital_radius': 48,\n                'inclination':\
    \ 0.8,\n                'moons': {\n                    'Miranda': {\n       \
    \                 'color': 'gray',\n                        'size': 3,\n     \
    \                   'orbital_period': 1.413,\n                        'orbital_radius':\
    \ 5.08,\n                        'inclination': 4.34\n                    },\n\
    \                    'Ariel': {\n                        'color': 'lightgray',\n\
    \                        'size': 4,\n                        'orbital_period':\
    \ 2.520,\n                        'orbital_radius': 7.27,\n                  \
    \      'inclination': 0.04\n                    },\n                    'Umbriel':\
    \ {\n                        'color': 'darkgray',\n                        'size':\
    \ 4,\n                        'orbital_period': 4.144,\n                     \
    \   'orbital_radius': 10.12,\n                        'inclination': 0.13\n  \
    \                  },\n                    'Titania': {\n                    \
    \    'color': 'gray',\n                        'size': 5,\n                  \
    \      'orbital_period': 8.706,\n                        'orbital_radius': 16.84,\n\
    \                        'inclination': 0.08\n                    },\n       \
    \             'Oberon': {\n                        'color': 'gray',\n        \
    \                'size': 5,\n                        'orbital_period': 13.463,\n\
    \                        'orbital_radius': 22.75,\n                        'inclination':\
    \ 0.07\n                    }\n                }\n            },\n           \
    \ 'Neptune': {\n                'color': 'blue',\n                'size': 45,\n\
    \                'orbital_period': 164.79,\n                'orbital_radius':\
    \ 75,\n                'inclination': 1.8,\n                'moons': {\n     \
    \               'Naiad': {\n                        'color': 'gray',\n       \
    \                 'size': 2,\n                        'orbital_period': 0.294,\n\
    \                        'orbital_radius': 3.18,\n                        'inclination':\
    \ 4.75\n                    },\n                    'Thalassa': {\n          \
    \              'color': 'gray',\n                        'size': 2,\n        \
    \                'orbital_period': 0.311,\n                        'orbital_radius':\
    \ 3.32,\n                        'inclination': 0.21\n                    },\n\
    \                    'Despina': {\n                        'color': 'gray',\n\
    \                        'size': 2,\n                        'orbital_period':\
    \ 0.335,\n                        'orbital_radius': 3.51,\n                  \
    \      'inclination': 0.07\n                    },\n                    'Galatea':\
    \ {\n                        'color': 'gray',\n                        'size':\
    \ 3,\n                        'orbital_period': 0.429,\n                     \
    \   'orbital_radius': 4.18,\n                        'inclination': 0.05\n   \
    \                 },\n                    'Larissa': {\n                     \
    \   'color': 'gray',\n                        'size': 3,\n                   \
    \     'orbital_period': 0.555,\n                        'orbital_radius': 4.97,\n\
    \                        'inclination': 0.20\n                    },\n       \
    \             'Proteus': {\n                        'color': 'darkgray',\n   \
    \                     'size': 4,\n                        'orbital_period': 1.122,\n\
    \                        'orbital_radius': 7.96,\n                        'inclination':\
    \ 0.08\n                    },\n                    'Triton': {\n            \
    \            'color': 'pink',\n                        'size': 8,\n          \
    \              'orbital_period': 5.877,\n                        'orbital_radius':\
    \ 14.33,\n                        'inclination': 156.885  # Retrograde orbit\n\
    \                    },\n                    'Nereid': {\n                   \
    \     'color': 'gray',\n                        'size': 3,\n                 \
    \       'orbital_period': 360.13,\n                        'orbital_radius': 222.65,\n\
    \                        'inclination': 7.23\n                    }\n        \
    \        }\n            },\n            'Pluto': {\n                'color': 'brown',\n\
    \                'size': 15,\n                'orbital_period': 248.09,\n    \
    \            'orbital_radius': 79,\n                'inclination': 17.16,\n  \
    \              'moons': {\n                    'Charon': {\n                 \
    \       'color': 'gray',\n                        'size': 7,\n               \
    \         'orbital_period': 6.387,\n                        'orbital_radius':\
    \ 17.53,\n                        'inclination': 0.001\n                    },\n\
    \                    'Nix': {\n                        'color': 'gray',\n    \
    \                    'size': 2,\n                        'orbital_period': 24.856,\n\
    \                        'orbital_radius': 48.69,\n                        'inclination':\
    \ 0.133\n                    },\n                    'Hydra': {\n            \
    \            'color': 'gray',\n                        'size': 2,\n          \
    \              'orbital_period': 38.206,\n                        'orbital_radius':\
    \ 64.74,\n                        'inclination': 0.242\n                    },\n\
    \                    'Kerberos': {\n                        'color': 'gray',\n\
    \                        'size': 1,\n                        'orbital_period':\
    \ 32.168,\n                        'orbital_radius': 57.78,\n                \
    \        'inclination': 0.389\n                    },\n                    'Styx':\
    \ {\n                        'color': 'gray',\n                        'size':\
    \ 1,\n                        'orbital_period': 20.162,\n                    \
    \    'orbital_radius': 42.65,\n                        'inclination': 0.809\n\
    \                    }\n                }\n            }\n        }\n    }\n\n\
    \n"
  metadata:
    performance: {}
    history: Chunk generated from lines 11 to 334.
    error_bars: null
- chunk_id: '010'
  description: Chunk 10
  enabled: true
  content: "class SolarSystemAnimation3D:\n    \n    def __init__(self, style='default',\
    \ elev=20, azim=45):\n        # Set up the 3D figure\n        plt.style.use(style)\n\
    \        self.fig = plt.figure(figsize=(16, 9))\n        self.ax = self.fig.add_subplot(111,\
    \ projection='3d')\n        \n        self.elev = elev\n        self.azim = azim\n\
    \        \n        # Extract settings from the new Config structure\n        self.settings\
    \ = Config.SETTINGS\n        self.frames = self.settings['frames']\n        self.camera_distance\
    \ = self.settings['camera_distance']\n        self.min_camera_distance = self.settings['min_camera_distance']\n\
    \        self.max_camera_distance = self.settings['max_camera_distance']\n   \
    \     self.zoom_speed = self.settings['zoom_speed']\n        self.base_speed =\
    \ self.settings['base_speed']\n        \n        # Extract planet data\n     \
    \   self.planets = self.settings['planets']\n        \n        # Extract asteroid\
    \ counts\n        asteroid_counts = self.settings['asteroid_counts']\n       \
    \ self.num_asteroids = asteroid_counts['belt']\n        self.num_hildas = asteroid_counts['hildas']\n\
    \        self.num_trojans = asteroid_counts['trojans']\n        self.num_kuiper\
    \ = asteroid_counts['kuiper']\n        self.num_inner_oort = asteroid_counts['inner_oort']\n\
    \        self.num_outer_oort = asteroid_counts['outer_oort']\n        \n     \
    \   # Initialize positions\n        self.init_positions()\n        \n    def init_positions(self):\n\
    \        # Initialize planet positions\n        self.planet_positions = {planet:\
    \ {'x': [], 'y': [], 'z': []} for planet in self.planets.keys()}\n        self.moon_positions\
    \ = {planet: {moon: {'x': [], 'y': [], 'z': []} \n                           \
    \ for moon in properties['moons'].keys()} \n                            for planet,\
    \ properties in self.planets.items()}\n        \n        # Initialize main belt\
    \ asteroids\n        self.belt_angles = np.random.uniform(0, 2*np.pi, self.num_asteroids)\n\
    \        self.belt_radii = np.random.uniform(5, 11, self.num_asteroids)\n    \
    \    self.belt_eccentricity = np.random.uniform(0.1, 0.3, self.num_asteroids)\n\
    \        self.belt_inclination = np.random.uniform(-20, 20, self.num_asteroids)\n\
    \        self.belt_phase = np.random.uniform(0, 2*np.pi, self.num_asteroids)\n\
    \        self.belt_ascending_nodes = np.random.uniform(0, 2*np.pi, self.num_asteroids)\n\
    \        \n        # Initialize Hildas\n        self.hilda_angles = []\n     \
    \   for angle in [0, 2*np.pi/3, 4*np.pi/3]:\n            cluster_angles = np.random.normal(angle,\
    \ 0.5, self.num_hildas//3)\n            self.hilda_angles.extend(cluster_angles)\n\
    \        self.hilda_angles = np.array(self.hilda_angles)\n        jupiter_radius\
    \ = self.planets['Jupiter']['orbital_radius']\n        self.hilda_radii = np.random.normal(jupiter_radius\
    \ * 0.8, 0.8, len(self.hilda_angles))\n        self.hilda_inclination = np.random.uniform(-10,\
    \ 10, len(self.hilda_angles))\n        self.hilda_phase = np.random.uniform(0,\
    \ 2*np.pi, len(self.hilda_angles))\n        \n        # Initialize Trojans\n \
    \       self.trojan_angles1 = np.random.normal(np.pi/3, 0.4, self.num_trojans)\n\
    \        self.trojan_angles2 = np.random.normal(5*np.pi/3, 0.4, self.num_trojans)\n\
    \        self.trojan_radii = np.random.normal(jupiter_radius, 1.0, self.num_trojans)\n\
    \        self.trojan_inclination = np.random.uniform(-15, 15, self.num_trojans)\n\
    \        self.trojan_phase = np.random.uniform(0, 2*np.pi, self.num_trojans)\n\
    \        \n        # Initialize Kuiper Belt, Inner Oort Cloud, and Outer Oort\
    \ Cloud positions\n        # [Previous initialization code remains the same]\n\
    \        self.kuiper_angles = np.random.uniform(0, 2*np.pi, self.num_kuiper)\n\
    \        self.kuiper_radii = np.random.uniform(80, 120, self.num_kuiper)\n   \
    \     self.kuiper_inclination = np.random.uniform(-30, 30, self.num_kuiper)\n\
    \        self.kuiper_eccentricity = np.random.uniform(0.1, 0.3, self.num_kuiper)\n\
    \        self.kuiper_ascending_nodes = np.random.uniform(0, 2*np.pi, self.num_kuiper)\n\
    \        \n        # Initialize Inner Oort Cloud (Hills Cloud)\n        self.inner_oort_phi\
    \ = np.random.uniform(0, 2*np.pi, self.num_inner_oort)\n        self.inner_oort_theta\
    \ = np.random.normal(np.pi/2, 0.5, self.num_inner_oort)\n        self.inner_oort_radii\
    \ = np.random.power(0.7, self.num_inner_oort) * 18000 + 2000\n        self.inner_oort_rotation\
    \ = np.random.uniform(0, 2*np.pi, self.num_inner_oort)\n        \n        # Initialize\
    \ Outer Oort Cloud\n        self.outer_oort_phi = np.random.uniform(0, 2*np.pi,\
    \ self.num_outer_oort)\n        self.outer_oort_theta = np.arccos(2*np.random.uniform(0,\
    \ 1, self.num_outer_oort) - 1)\n        self.outer_oort_radii = np.random.power(0.5,\
    \ self.num_outer_oort) * 80000 + 20000\n        self.outer_oort_rotation = np.random.uniform(0,\
    \ 2*np.pi, self.num_outer_oort)\n\n    def update(self, frame):\n        print(f\"\
    {frame}\")\n        self.ax.clear()\n        \n        # Calculate camera distance\
    \ with smooth zoom\n        self.camera_distance = self.max_camera_distance -\
    \ (self.max_camera_distance - self.min_camera_distance) * (1 - np.exp(-self.zoom_speed\
    \ * frame))\n        speed_scale = max(0.1, (self.camera_distance / self.max_camera_distance)\
    \ ** 0.3)\n        current_speed = self.base_speed * speed_scale\n\n        #\
    \ Get Jupiter's planet angle for trojans/hildas\n        jupiter_planet_angle\
    \ = None\n        for planet, properties in self.planets.items():\n          \
    \  if planet == 'Jupiter':\n                angular_velocity = 2 * np.pi / properties['orbital_period']\n\
    \                jupiter_planet_angle = -(current_speed * frame * angular_velocity)\n\
    \                break\n\n        # Update planet positions\n        for planet,\
    \ properties in self.planets.items():\n            angular_velocity = 2 * np.pi\
    \ / properties['orbital_period']\n            planet_angle = -(current_speed *\
    \ frame * angular_velocity)\n            \n            planet_x, planet_y, planet_z\
    \ = self.calculate_3d_position(\n                properties['orbital_radius'],\n\
    \                planet_angle,\n                properties['inclination']\n  \
    \          )\n            self.planet_positions[planet]['x'] = planet_x\n    \
    \        self.planet_positions[planet]['y'] = planet_y\n            self.planet_positions[planet]['z']\
    \ = planet_z\n            \n            # Update moon positions\n            for\
    \ moon, moon_props in properties['moons'].items():\n                moon_period\
    \ = moon_props['orbital_period'] / (365.25 * properties['orbital_period'])\n \
    \               moon_angular_velocity = 2 * np.pi / moon_period\n            \
    \    moon_angle = -(current_speed * frame * moon_angular_velocity)\n         \
    \       \n                moon_local_x, moon_local_y, moon_local_z = self.calculate_3d_position(\n\
    \                    moon_props['orbital_radius'] * 0.01,\n                  \
    \  moon_angle,\n                    moon_props['inclination']\n              \
    \  )\n                \n                self.moon_positions[planet][moon]['x']\
    \ = planet_x + moon_local_x\n                self.moon_positions[planet][moon]['y']\
    \ = planet_y + moon_local_y\n                self.moon_positions[planet][moon]['z']\
    \ = planet_z + moon_local_z\n\n        # Draw orbital paths\n        theta = np.linspace(0,\
    \ 2*np.pi, 100)\n        for planet, properties in self.planets.items():\n   \
    \         x, y, z = self.calculate_3d_position(\n                properties['orbital_radius'],\n\
    \                theta,\n                properties['inclination']\n         \
    \   )\n            opacity, _ = self.calculate_visibility((x, y, z), self.camera_distance)\n\
    \            self.ax.plot(x, y, z, 'b-', alpha=opacity.mean() * 0.3)\n       \
    \     \n            # Draw moon orbits\n            planet_pos = self.planet_positions[planet]\n\
    \            for moon, moon_props in properties['moons'].items():\n          \
    \      moon_x, moon_y, moon_z = self.calculate_3d_position(\n                \
    \    moon_props['orbital_radius'] * 0.01,\n                    theta,\n      \
    \              moon_props['inclination']\n                )\n                moon_orbit_x\
    \ = planet_pos['x'] + moon_x\n                moon_orbit_y = planet_pos['y'] +\
    \ moon_y\n                moon_orbit_z = planet_pos['z'] + moon_z\n          \
    \      \n                moon_opacity, _ = self.calculate_visibility(\n      \
    \              (moon_orbit_x, moon_orbit_y, moon_orbit_z),\n                 \
    \   self.camera_distance\n                )\n                self.ax.plot(moon_orbit_x,\
    \ moon_orbit_y, moon_orbit_z,\n                            'gray', alpha=moon_opacity.mean()\
    \ * 0.2, linewidth=0.5)\n\n        # Calculate asteroid belt positions using Kepler's\
    \ Third Law\n        belt_orbital_period = np.sqrt(self.belt_radii ** 3)\n   \
    \     belt_velocities = 2 * np.pi / belt_orbital_period\n        belt_angles_update\
    \ = self.belt_angles - current_speed * frame * belt_velocities\n        \n   \
    \     belt_radii_update = self.belt_radii * (1 + self.belt_eccentricity * np.cos(belt_angles_update))\n\
    \        belt_x, belt_y, belt_z = self.calculate_3d_position(\n            belt_radii_update,\n\
    \            belt_angles_update,\n            self.belt_inclination,\n       \
    \     self.belt_ascending_nodes\n        )\n        \n        # Hildas at 2:3\
    \ resonance with Jupiter\n        hilda_angles_update = self.hilda_angles + jupiter_planet_angle\
    \ * (2/3)\n        hilda_x, hilda_y, hilda_z = self.calculate_3d_position(\n \
    \           self.hilda_radii,\n            hilda_angles_update,\n            self.hilda_inclination\n\
    \        )\n        \n        # Trojans at Jupiter's L4 and L5 points\n      \
    \  trojan_x1, trojan_y1, trojan_z1 = self.calculate_3d_position(\n           \
    \ self.trojan_radii,\n            self.trojan_angles1 + jupiter_planet_angle,\n\
    \            self.trojan_inclination\n        )\n        trojan_x2, trojan_y2,\
    \ trojan_z2 = self.calculate_3d_position(\n            self.trojan_radii,\n  \
    \          self.trojan_angles2 + jupiter_planet_angle,\n            self.trojan_inclination\n\
    \        )\n        \n        # Kuiper Belt with proper Keplerian motion\n   \
    \     kuiper_orbital_period = np.sqrt(self.kuiper_radii ** 3)\n        kuiper_velocities\
    \ = 2 * np.pi / kuiper_orbital_period\n        kuiper_angles_update = self.kuiper_angles\
    \ - current_speed * frame * kuiper_velocities\n        \n        kuiper_radii_update\
    \ = self.kuiper_radii * (1 + self.kuiper_eccentricity * np.cos(kuiper_angles_update))\n\
    \        kuiper_x, kuiper_y, kuiper_z = self.calculate_3d_position(\n        \
    \    kuiper_radii_update,\n            kuiper_angles_update,\n            self.kuiper_inclination,\n\
    \            self.kuiper_ascending_nodes\n        )\n        \n        # Calculate\
    \ visibilities\n        belt_opacity, belt_size = self.calculate_visibility((belt_x,\
    \ belt_y, belt_z), self.camera_distance)\n        hilda_opacity, hilda_size =\
    \ self.calculate_visibility((hilda_x, hilda_y, hilda_z), self.camera_distance)\n\
    \        trojan_opacity1, trojan_size1 = self.calculate_visibility((trojan_x1,\
    \ trojan_y1, trojan_z1), self.camera_distance)\n        trojan_opacity2, trojan_size2\
    \ = self.calculate_visibility((trojan_x2, trojan_y2, trojan_z2), self.camera_distance)\n\
    \        kuiper_opacity, kuiper_size = self.calculate_visibility((kuiper_x, kuiper_y,\
    \ kuiper_z), self.camera_distance)\n        \n        # Calculate Oort Cloud positions\
    \ with much slower motion\n        inner_orbital_period = np.sqrt(self.inner_oort_radii\
    \ ** 3)\n        inner_velocities = 2 * np.pi / inner_orbital_period\n       \
    \ inner_angles = self.inner_oort_rotation - current_speed * frame * inner_velocities\
    \ * 0.001\n        \n        inner_x = self.inner_oort_radii * np.sin(self.inner_oort_theta)\
    \ * np.cos(self.inner_oort_phi + inner_angles)\n        inner_y = self.inner_oort_radii\
    \ * np.sin(self.inner_oort_theta) * np.sin(self.inner_oort_phi + inner_angles)\n\
    \        inner_z = self.inner_oort_radii * np.cos(self.inner_oort_theta)\n   \
    \     \n        outer_orbital_period = np.sqrt(self.outer_oort_radii ** 3)\n \
    \       outer_velocities = 2 * np.pi / outer_orbital_period\n        outer_angles\
    \ = self.outer_oort_rotation - current_speed * frame * outer_velocities * 0.0005\n\
    \        \n        outer_x = self.outer_oort_radii * np.sin(self.outer_oort_theta)\
    \ * np.cos(self.outer_oort_phi + outer_angles)\n        outer_y = self.outer_oort_radii\
    \ * np.sin(self.outer_oort_theta) * np.sin(self.outer_oort_phi + outer_angles)\n\
    \        outer_z = self.outer_oort_radii * np.cos(self.outer_oort_theta)\n   \
    \     \n        inner_opacity, inner_size = self.calculate_visibility(\n     \
    \       (inner_x, inner_y, inner_z),\n            self.camera_distance,\n    \
    \        max_distance=100000\n        )\n        outer_opacity, outer_size = self.calculate_visibility(\n\
    \            (outer_x, outer_y, outer_z),\n            self.camera_distance,\n\
    \            max_distance=100000\n        )\n        \n        # Plot everything\n\
    \        self.ax.scatter([0], [0], [0], c='yellow', s=100)  # Sun\n        \n\
    \        # Plot planets and moons\n        for planet, pos in self.planet_positions.items():\n\
    \            properties = self.planets[planet]\n            planet_opacity, planet_size\
    \ = self.calculate_visibility(\n                (pos['x'], pos['y'], pos['z']),\n\
    \                self.camera_distance\n            )\n            \n         \
    \   self.ax.scatter(pos['x'], pos['y'], pos['z'],\n                        c=properties['color'],\n\
    \                        s=properties['size'] * planet_size[0],\n            \
    \            alpha=planet_opacity[0])\n            \n            if planet_opacity[0]\
    \ > 0.3:\n                self.ax.text(pos['x'], pos['y'], pos['z'], planet, fontsize=8)\n\
    \            \n            for moon, moon_props in properties['moons'].items():\n\
    \                moon_pos = self.moon_positions[planet][moon]\n              \
    \  moon_opacity, moon_size = self.calculate_visibility(\n                    (moon_pos['x'],\
    \ moon_pos['y'], moon_pos['z']),\n                    self.camera_distance\n \
    \               )\n                \n                self.ax.scatter(moon_pos['x'],\
    \ moon_pos['y'], moon_pos['z'],\n                            c=moon_props['color'],\n\
    \                            s=moon_props['size'] * moon_size[0],\n          \
    \                  alpha=moon_opacity[0])\n        \n        # Plot asteroid populations\n\
    \        self.ax.scatter(belt_x, belt_y, belt_z, c='gray', s=1 * belt_size, alpha=belt_opacity)\n\
    \        self.ax.scatter(hilda_x, hilda_y, hilda_z, c='gray', s=1 * hilda_size,\
    \ alpha=hilda_opacity)\n        self.ax.scatter(trojan_x1, trojan_y1, trojan_z1,\
    \ c='gray', s=1 * trojan_size1, alpha=trojan_opacity1)\n        self.ax.scatter(trojan_x2,\
    \ trojan_y2, trojan_z2, c='gray', s=1 * trojan_size2, alpha=trojan_opacity2)\n\
    \        self.ax.scatter(kuiper_x, kuiper_y, kuiper_z, c='gray', s=1 * kuiper_size,\
    \ alpha=kuiper_opacity)\n        \n        # Plot Oort Clouds\n        self.ax.scatter(inner_x,\
    \ inner_y, inner_z,\n                    c='lightblue', s=0.8 * inner_size, alpha=inner_opacity\
    \ * 0.4,\n                    label='Hills Cloud')\n        self.ax.scatter(outer_x,\
    \ outer_y, outer_z,\n                    c='lightgray', s=0.5 * outer_size, alpha=outer_opacity\
    \ * 0.3,\n                    label='Outer Oort Cloud')\n        \n        # Update\
    \ view limits\n        max_radius = max(self.outer_oort_radii.max(), self.inner_oort_radii.max())\n\
    \        limit = self.camera_distance * (1 + np.log10(max_radius / self.camera_distance))\n\
    \        self.ax.set_xlim(-limit, limit)\n        self.ax.set_ylim(-limit, limit)\n\
    \        self.ax.set_zlim(-limit, limit)\n        self.ax.set_axis_off()\n   \
    \     \n        plt.subplots_adjust(left=-.5, bottom=-2, right=1.5, top=3, wspace=None,\
    \ hspace=None)\n        self.ax.view_init(elev=self.elev, azim=self.azim)\n  \
    \      self.ax.set_title('Complete Solar System Animation', pad=20)\n\n      \
    \  \n"
  metadata:
    performance: {}
    history: Chunk generated from lines 335 to 639.
    error_bars: null
- chunk_id: '011'
  description: Chunk 11
  enabled: true
  content: "    def calculate_oort_positions(self, frame):\n        \"\"\"Calculate\
    \ positions for both Inner and Outer Oort Cloud objects\"\"\"\n        # Inner\
    \ Oort Cloud (Hills Cloud) - slightly faster motion\n        inner_angular_velocity\
    \ = 0.00002 / np.sqrt(self.inner_oort_radii)\n        inner_angles = self.inner_oort_rotation\
    \ + self.base_speed * frame * inner_angular_velocity\n        \n        inner_x\
    \ = self.inner_oort_radii * np.sin(self.inner_oort_theta) * np.cos(self.inner_oort_phi\
    \ + inner_angles)\n        inner_y = self.inner_oort_radii * np.sin(self.inner_oort_theta)\
    \ * np.sin(self.inner_oort_phi + inner_angles)\n        inner_z = self.inner_oort_radii\
    \ * np.cos(self.inner_oort_theta)\n        \n        # Outer Oort Cloud - slower\
    \ motion\n        outer_angular_velocity = 0.00001 / np.sqrt(self.outer_oort_radii)\n\
    \        outer_angles = self.outer_oort_rotation + self.base_speed * frame * outer_angular_velocity\n\
    \        \n        outer_x = self.outer_oort_radii * np.sin(self.outer_oort_theta)\
    \ * np.cos(self.outer_oort_phi + outer_angles)\n        outer_y = self.outer_oort_radii\
    \ * np.sin(self.outer_oort_theta) * np.sin(self.outer_oort_phi + outer_angles)\n\
    \        outer_z = self.outer_oort_radii * np.cos(self.outer_oort_theta)\n   \
    \     \n        return (inner_x, inner_y, inner_z), (outer_x, outer_y, outer_z)\n\
    \        \n    def calculate_3d_position(self, radius, angle, inclination, ascending_node=0):\n\
    \        # Convert inclination to radians\n        incl_rad = np.radians(inclination)\n\
    \        \n        # Calculate position in orbital plane\n        # Let sine and\
    \ cosine handle the periodicity naturally\n        x_orbit = radius * np.cos(angle)\n\
    \        y_orbit = radius * np.sin(angle)\n        \n        # Apply inclination\
    \ and ascending node rotation\n        x = (x_orbit * np.cos(ascending_node) -\
    \ \n            y_orbit * np.cos(incl_rad) * np.sin(ascending_node))\n       \
    \ y = (x_orbit * np.sin(ascending_node) + \n            y_orbit * np.cos(incl_rad)\
    \ * np.cos(ascending_node))\n        z = y_orbit * np.sin(incl_rad)\n        \n\
    \        return x, y, z\n    \n    def calculate_visibility(self, positions, camera_distance,\
    \ max_distance=50):\n        \"\"\"Calculate opacity based on distance from camera\"\
    \"\"\n        # Calculate camera position that rotates with the view\n       \
    \ azim = np.radians(45)  # Match the view_init azimuth\n        elev = np.radians(20)\
    \  # Match the view_init elevation\n        \n        x = camera_distance * np.cos(elev)\
    \ * np.sin(azim)\n        y = camera_distance * np.cos(elev) * np.cos(azim)\n\
    \        z = camera_distance * np.sin(elev)\n        \n        camera_pos = np.array([x,\
    \ y, z])\n        \n        if isinstance(positions[0], np.ndarray):\n       \
    \     points = np.vstack((positions[0], positions[1], positions[2])).T\n     \
    \   else:\n            points = np.array([[positions[0], positions[1], positions[2]]])\n\
    \            \n        distances = np.linalg.norm(points - camera_pos, axis=1)\n\
    \        \n        # Calculate opacity based on distance\n        max_opacity\
    \ = 0.8\n        min_opacity = 0.0\n        opacity = np.clip(max_opacity * (1\
    \ - distances/max_distance), min_opacity, max_opacity)\n        \n        # Add\
    \ distance-based size scaling\n        size_scale = np.clip(1.5 * (1 - distances/max_distance),\
    \ 0.2, 1.0)\n        \n        return opacity, size_scale\n        \n    def animate(self):\n\
    \        anim = FuncAnimation(self.fig, self.update, frames=self.frames, interval=50,\
    \ blit=False)\n        plt.show()\n        \n    def save(self, filename):\n \
    \       anim = FuncAnimation(self.fig, self.update, frames=self.frames, interval=50,\
    \ blit=False)\n        self.fig.set_size_inches(16, 9)\n        self.fig.set_dpi(100)\n\
    \        anim.save(filename, writer=PillowWriter(fps=20))\n        print(f\"Animation\
    \ saved as {filename}\")\n        \n    def save1080p(self, filename):\n     \
    \   \"\"\"\n        Save the animation in 1080p resolution (1920x1080) using H.264\
    \ codec\n        \n        Parameters:\n        filename (str): The output filename\
    \ (should end in .mp4 or .mov)\n        \"\"\"\n        anim = FuncAnimation(self.fig,\
    \ self.update, frames=self.frames, interval=50, blit=False)\n        self.fig.set_size_inches(16,\
    \ 9)  # 16:9 aspect ratio\n        self.fig.set_dpi(120)  # 1920/16 = 120 DPI\
    \ for 1080p\n        writer = FFMpegWriter(fps=30, codec='h264', bitrate=8000)\n\
    \        anim.save(filename, writer=writer)\n        print(f\"Animation saved\
    \ as {filename}\")\n\n    def save4k(self, filename):\n        anim = FuncAnimation(self.fig,\
    \ self.update, frames=self.frames, interval=50, blit=False)\n        self.fig.set_size_inches(16,\
    \ 9)\n        self.fig.set_dpi(240)\n        writer = FFMpegWriter(fps=30, codec='h264')\n\
    \        anim.save(filename, writer=writer)\n        print(f\"Animation saved\
    \ as {filename}\")\n\n\n\n"
  metadata:
    performance: {}
    history: Chunk generated from lines 640 to 741.
    error_bars: null
- chunk_id: '012'
  description: Chunk 12
  enabled: true
  content: 'styles = {''light'': ''default'', ''dark'': ''dark_background''}

    '
  metadata:
    performance: {}
    history: Chunk generated from lines 742 to 742.
    error_bars: null
- chunk_id: '013'
  description: Chunk 13
  enabled: true
  content: "for version, style in styles.items():\n    # Default 3D Perspective\n\
    \    solar_system = SolarSystemAnimation3D(style=style, elev=20, azim=45)\n  \
    \  solar_system.save(os.path.join(OS_PATH, f\"output/complete_solar_system_3d_{version}.gif\"\
    ))\n    solar_system.save1080p(os.path.join(OS_PATH, f\"output/complete_solar_system_3d_{version}_1080p.mp4\"\
    ))\n    solar_system.save4k(os.path.join(OS_PATH, f\"output/complete_solar_system_3d_{version}_4k.mov\"\
    ))\n    #solar_system.animate()\n\n    # Top-Down View\n    solar_system_top_down\
    \ = SolarSystemAnimation3D(style=style, elev=90, azim=0)\n    solar_system_top_down.save(os.path.join(OS_PATH,\
    \ f\"output/complete_solar_system_3d_top_down_{version}.gif\"))\n    solar_system_top_down.save1080p(os.path.join(OS_PATH,\
    \ f\"output/complete_solar_system_3d_top_down_{version}_1080p.mp4\"))\n    solar_system_top_down.save4k(os.path.join(OS_PATH,\
    \ f\"output/complete_solar_system_3d_top_down_{version}_4k.mov\"))\n    #solar_system_top_down.animate()\n"
  metadata:
    performance: {}
    history: Chunk generated from lines 743 to 756.
    error_bars: null
